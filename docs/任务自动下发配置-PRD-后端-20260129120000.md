# 任务自动下发配置 - 后端PRD文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 产品名称 | 任务自动下发配置 |
| 版本 | V1.3 |
| 创建日期 | 2026-01-28 |
| 更新日期 | 2026-01-29 |
| 所属模块 | 资产安全管理平台 - 系统维护 |
| 文档类型 | 后端PRD |

---

## 1. 需求背景

### 1.1 业务场景
安全运营团队需要定期对业务系统资产进行安全扫描检测（基线检测、弱口令检测、系统漏洞扫描、外部漏洞扫描），以满足集团安保考核要求：
- 每月/每两月需完成全量资产覆盖扫描
- 扫描结果用于集团数据上报
- 需避开业务高峰期（盲时）进行扫描

### 1.2 现状问题
- 手动创建扫描任务工作量大，容易遗漏
- 缺乏统一的调度管理机制
- 无法自动规避业务盲时
- 扫描失败或遗漏的资产需要人工排查补扫

### 1.3 目标
提供自动化的任务下发配置功能，实现：
- 按配置周期自动创建扫描任务
- 智能规避盲时下发
- 支持手动触发补充扫描
- 与AMR任务管理平台对接

---

## 2. 功能范围

本需求涵盖四种扫描类型的自动下发配置：
1. **基线检测** - 检测系统配置是否符合安全基线
2. **弱口令检测** - 检测系统账户是否存在弱口令
3. **系统漏洞扫描** - 检测系统内部漏洞
4. **外部漏洞扫描** - 检测对外暴露的漏洞

四种类型配置结构基本一致，差异点在"自动下发模式"部分（工具选择、模板选择）。

---

## 3. 配置项说明

### 3.1 自动下发参数

| 配置项 | 类型 | 取值范围 | 必填 | 说明 |
|--------|------|----------|------|------|
| 是否开启 | 开关 | 开/关 | 是 | 控制自动调度是否生效 |
| 每月开始扫描日期 | 下拉选择 | 1-31 | 是 | 每月几号开始自动创建任务，以最后一天为准（如选31号，2月则为28/29号） |
| 开始时间 | 时间选择 | 00:00-23:59 | 是 | 扫描日期当天的开始时间，默认00:00。需与盲时校验，不能配置在盲时范围内 |
| 单个任务下发最大资产数 | 数字输入 | 1-500 | 是 | 超过此数量则拆分为多个任务 |
| 任务超时最大等待时间 | 数字输入 | 1-10 | 是 | 单位：小时。等待上一轮任务完成的最大时长，最大不超过10小时 |
| 自动任务创建用户 | 下拉选择 | 系统用户列表 | 是 | 自动创建的任务归属用户 |

### 3.2 盲时配置

| 类型 | 配置方式 | 示例 |
|------|----------|------|
| 整月 | 选择月份 | 11月整月不扫描 |
| 指定日期 | 选择月-日 | 10-01、10-02（10月1日、2日不扫描） |
| 时间段 | 选择时-分 ~ 时-分 | 06:00-18:00（每天该时段不扫描） |

**注意**：时间段盲时不支持跨天配置（如 22:00-06:00），开始时间必须小于结束时间。

### 3.3 资产范围配置

| 配置项 | 类型 | 选项 | 说明 |
|--------|------|------|------|
| 选择资产范围 | 单选 | 全部资产 / 仅上报资产 / 非上报资产 | 基于资产的"是否上报"属性筛选 |
| 选择业务系统范围 | 下拉多选 | 业务系统列表 | 支持按名称模糊搜索，按资产组显示顺序排序 |

### 3.4 自动下发模式配置

| 配置项 | 类型 | 说明 |
|--------|------|------|
| 选择工具 | 单选卡片 | 展示可用的扫描工具及版本 |
| 合规模板 | 下拉选择 | 选择扫描使用的模板，模板与工具、专题有对应关系 |
| 保存原始结果 | 复选框 | 仅基线检测和弱口令检测需要，默认勾选 |

---

## 4. 调度机制设计

### 4.1 技术方案

采用 **Spring TaskScheduler 动态调度**方案，按需触发，避免无效轮询。

**核心思路**：
- 不使用固定频率轮询，而是计算出"下次执行时间"，精确触发
- 配置保存时计算下次执行时间，创建 pending 状态的调度记录
- 任务执行完成后，计算下一次执行时间，创建新的调度记录

**优势**：
- 零资源浪费（配置20号执行，1-19号无任何调度开销）
- 无需引入第三方依赖（Spring原生支持）
- 盲时提前计算，直接跳到可执行时间点

### 4.2 轮次状态定义

| 状态 | 说明 | 列表展示 |
|------|------|----------|
| pending | 已创建调度记录，等待到达执行时间 | ✅ 展示 |
| waiting | 到达执行时间，正在等待上轮任务完成 | ✅ 展示 |
| running | 调度执行中（正在创建任务） | ✅ 展示 |
| success | 所有任务创建成功 | ✅ 展示 |
| failed | 所有任务创建失败，或所有业务系统都无符合条件的资产 | ✅ 展示 |
| partial_failed | 部分任务创建成功，部分创建失败 | ✅ 展示 |
| skipped | 等待超时，上轮仍未完成，本轮跳过 | ✅ 展示 |
| cancelled | 已取消（手动调度被新的立即执行取代） | ❌ 不展示 |

**说明**：轮次状态反映的是"任务创建结果"，而非"任务执行结果"。任务创建后的实际执行状态通过 AMR 接口实时查询。

**状态流转**：
```
pending → waiting → running → success/failed/partial_failed
pending → waiting → skipped
pending → cancelled（被立即执行取代）
pending → running → success/failed/partial_failed（无需等待时直接执行）
```

### 4.3 下次执行时间计算逻辑

```
输入：每月扫描日期、开始时间、盲时配置
输出：下次执行时间（精确到分钟）

计算步骤：
1. 确定基准日期时间
   - 若当前日期 < 本月扫描日期 → 基准 = 本月扫描日期 + 配置的开始时间
   - 若当前日期 >= 本月扫描日期 → 基准 = 下月扫描日期 + 配置的开始时间
   - 特殊处理：扫描日期为31号，当月不足31天则取当月最后一天

2. 盲时规避（循环校验）
   - 检查基准日期是否在"整月盲时"内 → 跳到下一个非盲时月份
   - 检查基准日期是否在"指定日期盲时"内 → 跳到下一天 + 配置的开始时间
   - 检查基准时间是否在"时间段盲时"内 → 跳到盲时结束时间
   - **每次跳转后，需重新从步骤2开始校验，直到找到不在任何盲时内的可执行时间**
   
3. 距盲时间隔检查
   - 计算执行时间距离下一个盲时开始的间隔
   - 若间隔 < 配置的"距盲时时间间隔" → 跳到该盲时结束后

4. 输出最终的下次执行时间
```

### 4.4 调度生命周期

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              调度生命周期                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ┌──────────────────────────────────────────────────────────────────────────┐    │
│  │                       配置保存 / 手动触发                                 │    │
│  └──────────────────────────────────────────────────────────────────────────┘    │
│                                      │                                           │
│                                      ▼                                           │
│                  ┌───────────────────────────────────────┐                       │
│                  │ 计算下次执行时间，创建 pending 调度记录 │                       │
│                  └───────────────────────────────────────┘                       │
│                                      │                                           │
│                                      ▼                                           │
│                       ┌─────────────────────────────┐                            │
│                       │ 到达执行时间，触发调度        │                            │
│                       └─────────────────────────────┘                            │
│                                      │                                           │
│                                      ▼                                           │
│                       ┌─────────────────────────────┐                            │
│                       │ 是否存在 waiting/running     │                            │
│                       │ 状态的轮次？                 │                            │
│                       └─────────────────────────────┘                            │
│                            │                   │                                 │
│                            ▼                   ▼                                 │
│                    ┌─────────────┐    ┌─────────────────┐                        │
│                    │ 是：拒绝调度 │    │ 否：继续判断     │                        │
│                    │ 保持pending │    └─────────────────┘                        │
│                    └─────────────┘             │                                 │
│                                                ▼                                 │
│                       ┌─────────────────────────────┐                            │
│                       │ 最近一轮（非pending/waiting/ │                            │
│                       │ skipped/cancelled）是否有   │                            │
│                       │ 未完成任务？                 │                            │
│                       └─────────────────────────────┘                            │
│                            │         │                                           │
│         ┌──────────────────┘         └───────────────┐                           │
│         ▼                                            ▼                           │
│┌─────────────────┐                    ┌─────────────────────┐                    │
││ 无未完成任务     │                    │ 有未完成任务         │                    │
│└─────────────────┘                    └─────────────────────┘                    │
│         │                                            │                           │
│         ▼                                            ▼                           │
│┌─────────────────┐                    ┌─────────────────────┐                    │
││ 状态→running    │                    │ 状态→waiting        │                    │
││ 创建本轮任务     │                    │ 阻塞等待            │                    │
│└─────────────────┘                    │ 每10分钟检查一次     │                    │
│         │                             └─────────────────────┘                    │
│         │                                   │         │                          │
│         │                         ┌─────────┘         └────────┐                 │
│         │                         ▼                            ▼                 │
│         │              ┌─────────────────┐      ┌──────────────────┐             │
│         │              │ 上轮完成         │      │ 超时未完成        │             │
│         │              │ 状态→running    │      │ 状态→skipped     │             │
│         │              │ 创建本轮任务     │      └──────────────────┘             │
│         │              └─────────────────┘              │                        │
│         │                         │                     │                        │
│         ▼                         ▼                     │                        │
│┌─────────────────────────────────────────────────────────────┐                   │
││ 任务创建完成，更新轮次状态（success/failed/partial_failed）   │                   │
│└─────────────────────────────────────────────────────────────┘                   │
│                                      │                  │                        │
│                                      ▼                  ▼                        │
│                       ┌─────────────────────────────────────────────┐            │
│                       │ 检查是否已存在 pending 的自动调度            │            │
│                       │ 若不存在 → 创建新的 pending 记录             │            │
│                       │ （trigger_type = auto）                      │            │
│                       └─────────────────────────────────────────────┘            │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘

说明：
- 存在 waiting/running 状态的轮次时，拒绝新的调度，保持 pending 状态
- 被拒绝的 pending 会延迟10分钟后重新触发（重新注册调度任务）
- 阻塞等待期间每10分钟检查一次上轮任务状态
- 超时时间最大10小时，避免长时间阻塞
- 手动和自动 pending 可以共存，按时间先后独立触发
```

### 4.5 异常情况站内信通知

以下情况需要发送站内信通知用户，让用户及时知道系统存在问题，需要人工处理：

| 场景 | 站内信内容 |
|------|----------|
| 轮次跳过 | 【任务自动下发】{扫描类型}本月自动调度已跳过，原因：上轮任务未完成且已超时，请及时处理 |
| 调度失败 | 【任务自动下发】{扫描类型}本月自动调度失败，原因：{失败原因}，请及时处理 |

### 4.6 服务重启恢复

服务启动时自动恢复调度：
```
1. 查询所有已开启的扫描配置
2. 检查是否存在 running 状态的轮次：
   - 若存在：
     a. 说明任务创建过程被中断
     b. 检查该轮次已创建的任务数量（auto_scan_round_task 记录数）
     c. 若已创建任务数 = 0 → 标记为 failed，记录失败原因"服务重启导致任务创建中断"
     d. 若已创建任务数 > 0 → 标记为 partial_failed，记录失败原因"服务重启导致任务创建中断"
     e. 发送站内信通知用户
3. 检查是否存在 waiting 状态的轮次：
   - 若存在：
     a. 计算剩余等待时间 = 超时时间 - (当前时间 - 轮次创建时间)
     b. 剩余时间 > 0 → 恢复阻塞等待（继续循环检查上轮任务状态）
     c. 剩余时间 <= 0 → 标记为 skipped
4. 检查是否存在 cancelled 状态的轮次（可能是取消后、创建新记录前服务中断）：
   - 若存在最近的 cancelled 记录且无对应的后续 running/success/failed/partial_failed 记录：
     a. 说明"取消旧记录 + 创建新记录立即执行"操作被中断
     b. 发送站内信通知用户，提示手动触发操作被中断，需重新操作
5. 检查是否存在 pending 状态的轮次：
   - 若 plan_start_time > 当前时间 → 注册定时任务
   - 若 plan_start_time <= 当前时间 → 立即执行
6. 若不存在 pending 状态的自动调度轮次 → 根据配置计算下次执行时间，创建新的 pending 记录
```

### 4.7 配置变更处理

| 变更场景 | 处理方式 |
|----------|----------|
| 存在 pending 的手动调度 | 只保存配置，不影响已有的手动 pending。若不存在自动 pending 且修改了时间相关配置，则创建新的自动 pending |
| 存在 pending 的自动调度 | 仅当修改了影响调度时间的配置（扫描日期、开始时间、盲时配置）时，才重新计算执行时间并更新该 pending 记录；其他配置变更不影响已有的 pending 记录 |
| 不存在 pending 调度 | 根据新配置计算下次执行时间，创建新的 pending 自动调度记录 |
| 开启自动下发 | 计算下次执行时间，创建 pending 调度记录 |
| 关闭自动下发 | 仅取消自动调度的 pending，不影响手动 pending |
| 修改业务系统范围 | 同步更新所有 pending 状态轮次的 `target_system_ids` 和 `target_system_count` 字段 |

**配置生效时机说明**：
- 调度时间相关配置（扫描日期、开始时间、盲时）：影响 pending 记录的计划执行时间，保存时立即重新计算并更新
- 业务系统范围配置：保存时同步更新 pending 记录的 `target_system_ids` 和 `target_system_count`，执行时直接使用轮次表中的数据
- 资产范围、工具、模板等配置：在调度实际执行时实时查询，使用最新配置

### 4.7.1 多个 pending 共存规则

**允许多个 pending 共存**：手动调度和自动调度的 pending 可以同时存在，按时间先后独立触发。

**核心规则**：
1. **独立注册**：手动 pending 和自动 pending 各自独立注册到调度器，互不影响
2. **按时间触发**：谁的 plan_start_time 先到，谁先触发执行
3. **并发控制**：触发时检查是否存在 waiting/running 状态的轮次，若存在则拒绝执行，保持 pending 状态
4. **拒绝后重试**：被拒绝的 pending 延迟10分钟后重新注册调度任务，再次尝试触发
5. **不重复创建**：轮次执行完成后创建下次自动调度前，先检查是否已存在 pending 状态的自动调度，若存在则不重复创建

**场景示例**：
```
当前状态：
- 202601_自动_01（pending，计划1月20日 00:00）
- 用户手动触发，选择1月19日 10:00 定时执行
- 创建 202601_手动_02（pending，计划1月19日 10:00）

执行过程：
1月19日 10:00：
  - 202601_手动_02 触发
  - 检查并发控制 → 无 waiting/running → 执行
  - 执行完成，检查是否存在 pending 的自动调度 → 存在 202601_自动_01 → 不创建新的自动 pending

1月20日 00:00：
  - 202601_自动_01 触发
  - 检查并发控制 → 无 waiting/running → 执行（本月第2轮）
  - 执行完成，检查是否存在 pending 的自动调度 → 不存在 → 创建 202602_自动_01（计划2月20日）
```

### 4.8 轮次判断逻辑

调度触发时执行以下判断：

**步骤1：并发控制检查**

**目的**：防止多个调度同时执行，避免重复创建任务。

```
查询 auto_scan_round 是否存在 status in ('waiting', 'running') 的记录
- 若存在 → 拒绝本次调度
  - 自动调度：保持 pending 状态，延迟10分钟后重新注册调度任务，再次尝试触发
  - 手动触发：提示"当前存在执行中的调度，请等待完成后再操作"
- 若不存在 → 继续步骤2
```

**为什么需要这个检查？**
- `waiting` 状态：表示有一个调度正在等待上轮任务完成
- `running` 状态：表示有一个调度正在创建任务
- 如果不检查，可能出现两个调度同时检测到"上轮完成"，导致任务被创建两次

**步骤2：判断上轮任务是否完成**

**目的**：确保上一轮任务全部完成后，再创建新一轮任务。

```
1. 查询 auto_scan_round 最新一条"已执行过"的轮次
   - 筛选条件：status in ('running', 'success', 'failed', 'partial_failed')
   - 排除 pending（未开始）、waiting（等待中）、skipped（已跳过）、cancelled（已取消）

2. 若无历史轮次（首次执行）→ 视为"上轮已完成"，直接创建任务

3. 若有历史轮次 → 通过该轮次的 auto_scan_round_task 记录，关联 AMR 任务表查看任务状态

4. 判断结果：
   - 若无未完成任务 → 本轮状态改为 running，直接创建任务
   - 若有未完成任务 → 本轮状态改为 waiting，进入阻塞等待流程
```

**步骤3：阻塞等待流程**

```java
// 本轮状态改为 waiting
round.setStatus("waiting");

// 计算超时时间点
LocalDateTime timeoutAt = LocalDateTime.now().plusHours(config.getTimeoutHours());

// 阻塞等待（每10分钟检查一次）
while (LocalDateTime.now().isBefore(timeoutAt)) {
    if (isLastRoundCompleted()) {
        // 上轮完成，创建本轮任务
        round.setStatus("running");
        createTasks(round);
        break;
    }
    Thread.sleep(10 * 60 * 1000);  // 休眠10分钟
}

// 超时仍未完成
if (round.getStatus().equals("waiting")) {
    round.setStatus("skipped");
}

// 无论成功还是跳过，都创建下一次调度
createNextPendingRound();
```

**调度流程图**：
```
触发调度（pending 状态的轮次到达执行时间）
    │
    ▼
┌─────────────────────────────────────────┐
│ 步骤1：并发控制检查                       │
│ 是否存在 waiting/running 状态的轮次？     │
└─────────────────────────────────────────┘
    │
    ├─ 是 → 拒绝调度，保持 pending，延迟10分钟后重试
    │
    └─ 否 ↓
         │
         ▼
┌─────────────────────────────────────────┐
│ 步骤2：检查上轮任务是否完成               │
│ 查询最近一个已执行的轮次，调AMR查任务状态  │
└─────────────────────────────────────────┘
         │
         ├─ 上轮已完成 → 状态→running → 创建本轮任务
         │                              │
         │                              ▼
         │                    success/failed/partial_failed
         │
         └─ 上轮未完成 → 状态→waiting → 阻塞等待（最长N小时）
                                        │
                              ┌─────────┴─────────┐
                              ▼                   ▼
                          等待期间完成         超时仍未完成
                              │                   │
                              ▼                   ▼
                        状态→running          状态→skipped
                        创建本轮任务
    │
    ▼
根据配置计算下次执行时间，创建新的 pending 自动调度记录
```

**等待时间的含义**：本轮调度愿意等待上轮任务完成的最大时长。超过此时长说明任务可能卡住，本轮跳过，需人工处理卡住的任务。

### 4.9 任务拆分与创建逻辑

**拆分规则**：
- 按业务系统维度 + 最大资产数拆分
- 每个业务系统独立拆分，若该业务系统的资产数超过最大值，则拆分为多个任务
- **若业务系统下无符合条件的资产，则跳过该业务系统，不创建任务**
- 示例1：选择了10个业务系统，每个业务系统10个资产，最大资产数配置为10
  - 则创建10个任务，每个任务包含1个业务系统的10个资产
- 示例2：选择了1个业务系统，该业务系统有100个资产，最大资产数配置为10
  - 则创建10个任务，每个任务包含该业务系统的10个资产
- 示例3：选择了5个业务系统，其中2个业务系统下无资产
  - 则只为有资产的3个业务系统创建任务，跳过无资产的2个业务系统

**创建方式**：
- 按业务系统在资产组管理中的"显示顺序"，**逐个调用AMR接口创建任务**
- 一轮调度内，所有任务依次创建完成后，本轮调度即结束（不等待任务执行完成）
- 任务创建完成后，立即根据配置计算下次执行时间，创建新的 pending 自动调度记录

**轮次最终状态判定**：
- 轮次状态基于 AMR 接口调用结果判定，而非任务执行结果
- **success**：所有有资产的业务系统的任务都创建成功（AMR接口调用全部成功）
- **partial_failed**：部分业务系统的任务创建成功，部分创建失败
- **failed**：所有业务系统的任务都创建失败（AMR接口调用全部失败），或所有业务系统都无资产

**说明**：任务创建后的实际执行状态（扫描成功/失败）通过 AMR 接口实时查询，不影响轮次状态。轮次状态仅反映"任务是否成功创建"。

**任务执行顺序**：
- 任务的实际执行顺序由工具管理平台控制（非本系统职责）
- 工具管理侧有负载控制机制，前一个任务完成后才下发下一个到扫描工具
- 本系统只负责创建任务，不负责控制执行顺序

### 4.10 等待逻辑说明

**重要：等待判断只发生在"轮次与轮次之间"，不发生在"任务与任务之间"**

```
场景示例：
- 1月20日触发调度，创建10个任务 → 任务一次性全部创建 → 本轮结束
- 1月25日手动触发新轮次，创建5个任务 → 本轮结束
- 2月20日触发调度，判断最近一轮（1月25日手动触发的轮次，需为非pending/waiting/skipped/cancelled状态）的任务是否全部完成：
  - 全部完成 → 创建2月的任务
  - 有未完成 → 状态→waiting，阻塞等待最长10小时
    - 等待期间完成 → 创建2月任务
    - 超时仍未完成 → 状态→skipped，等3月再判断
```

**任务完不成的处理**：
- 单个任务卡住不会影响同轮次其他任务的创建（因为是一次性创建的）
- 单个任务卡住会影响下一轮次的创建（因为要判断上轮是否有未完成）
- 超过等待时间后，系统自动跳过本轮，用户需手动处理卡住的任务（终止或等待完成）

---

## 5. 盲时处理逻辑

### 5.1 盲时判断优先级
盲时判断顺序：整月 → 指定日期 → 时间段

### 5.2 业务规则
- 盲时仅控制任务下发时机，不控制任务执行时长
- 若任务执行跨越盲时，不会中断已执行的任务
- 盲时在计算"下次执行时间"时提前规避，而非触发时判断

### 5.3 盲时配置保存校验

**保存时校验规则**：
1. 检查盲时配置是否导致全年无可执行时间
2. 若配置了过多盲时（如12个月都配置为整月盲时），保存时提示"盲时配置过多，无法找到可执行时间，请调整配置"
3. 校验逻辑：尝试计算未来12个月内的下次执行时间，若无法找到可执行时间点则拒绝保存

---

## 6. 资产范围处理逻辑

### 6.1 业务系统选择规则
- 展示时保留父子节点的层级关系
- 勾选时不联动（勾选父节点不自动勾选子节点，勾选哪个就是哪个）
- 存储时平铺存储，不存储层级关系
- 不递归查询子节点

### 6.2 执行顺序
- 按业务系统在资产组管理中的"显示顺序"字段排序
- 调用AMR接口创建任务时，按此顺序依次创建

### 6.3 资产查询
- 根据所选业务系统ID + 资产范围条件查询资产列表
- 外部漏洞扫描需按资产类型过滤，只查询"应用"类型的资产（根据资产类型编码过滤）
- **若业务系统下无符合条件的资产（包括外部漏洞扫描过滤后无"应用"类型资产），则跳过该业务系统，不创建任务**

---

## 7. 手动触发逻辑

### 7.1 手动触发完整逻辑

**场景A：选择定时时间**

1. 校验时间是否在盲时内（含距盲时间隔）→ 在盲时内则提示重选
2. 检查是否存在 pending 状态的手动调度
   - 存在 → 更新该记录的计划执行时间（plan_start_time）
   - 不存在 → 创建新的 pending 手动调度记录（与已有的自动 pending 共存）
3. 到达时间后按正常流程执行
4. 执行完成后，检查是否存在 pending 的自动调度，若不存在则根据配置生成下一次自动调度记录

**场景B：不选时间（立即执行）**

1. 校验当前是否在盲时内（含距盲时间隔）→ 在盲时内则提示选择时间
2. 检查是否存在 pending 状态的手动调度
   - 存在 → 将该记录状态改为 cancelled，创建新记录立即执行
   - 不存在 → 创建新记录立即执行（与已有的自动 pending 共存）
3. 执行完成后，检查是否存在 pending 的自动调度，若不存在则根据配置生成下一次自动调度记录

**说明**：手动调度与自动调度的 pending 可以共存，按时间先后独立触发执行。

**手动触发流程图**：
```
用户点击"下发新一轮次任务" → 弹出配置弹窗 → 用户点击确认
        │
        ▼
并发控制检查：是否存在 waiting/running 状态的轮次？
        │
    ┌───┴───┐
    ▼       ▼
   是      否
    │       │
    ▼       ▼
  提示    用户是否选择了定时开始时间？
  拒绝          │
            ┌───┴───┐
            ▼       ▼
        选择时间   不选（立即）
            │       │
            ▼       ▼
    校验时间是否   校验当前是否
    在盲时内       在盲时内
    （含距盲时间隔）（含距盲时间隔）
            │       │
        ┌───┴───┐   ┌───┴───┐
        ▼       ▼   ▼       ▼
    在盲时内  不在  在盲时内  不在
        │       │   │       │
        ▼       ▼   ▼       ▼
    提示重选  继续  提示选择  继续
                │   时间     │
                ▼           ▼
        是否存在pending  是否存在pending
        的手动调度？     的手动调度？
            │               │
        ┌───┴───┐       ┌───┴───┐
        ▼       ▼       ▼       ▼
       存在   不存在   存在    不存在
        │       │       │       │
        ▼       ▼       ▼       ▼
    更新该   创建新   原pending  创建新
    pending  pending  →cancelled 记录
    记录     记录     创建新记录  立即执行
                      立即执行
```

### 7.2 资产范围说明

| 选项 | 逻辑 |
|------|------|
| 全部 | 当前配置的所有业务系统下的所有资产（根据资产范围筛选条件） |
| 上次扫描失败资产 | 最近一次完成的轮次中，扫描结果为失败的资产（不区分自动/手动） |
| 本轮未扫描到的资产 | 当前配置的全部资产 - 最近一次完成的轮次中已扫描过的资产（不含专题任务） |

**"本轮"定义**：指最近一次完成的轮次（状态为 success/failed/partial_failed），不区分自动或手动触发，不限于本月。

**说明**：
- **资产范围在实际执行时实时计算**，而非创建 pending 时计算
- "本轮未扫描到的资产"基于**执行时轮次表中记录的目标业务系统**计算
- 计算逻辑：根据轮次表中的 `target_system_ids` 查询当前资产列表，与最近一次完成的轮次关联的资产对比，找出不在该轮次任务中的资产

### 7.3 选择规则
- 选择"全部"时，其他两项置灰不可选
- "上次扫描失败资产"和"本轮未扫描到的资产"可同时勾选，取**并集**（失败的 + 未扫描的，去重）

### 7.4 下发校验

| 校验项 | 校验时机 | 失败提示 |
|--------|----------|----------|
| 是否存在 waiting/running 状态的轮次 | 点击确认时 | 当前存在执行中的调度，请等待完成后再操作 |
| 定时时间是否在盲时内 | 选择时间时 | 所选时间在盲时范围内，请重新选择 |
| 定时时间是否在距盲时间隔内 | 选择时间时 | 所选时间距离盲时不足X小时，请重新选择 |
| 当前时间是否在盲时内（立即执行） | 点击确认时 | 当前处于盲时，请选择定时执行时间 |
| 当前时间是否在距盲时间隔内（立即执行） | 点击确认时 | 当前距离盲时不足X小时，请选择定时执行时间 |
| 资产范围是否为空 | 实际执行时 | 当前无符合条件的资产（轮次标记为 failed） |

---

## 8. 与外部系统交互

### 8.1 AMR任务管理平台
- 调用AMR对外接口创建任务
- 传递参数：业务系统、资产列表、扫描工具、模板、创建用户等
- 任务状态同步：通过AMR接口查询任务执行状态

### 8.2 工具管理平台
- 任务创建后由AMR调度到工具管理平台
- 工具管理平台有负载控制机制（资产负载数）
- 任务按顺序执行：前一个任务完成后才下发下一个任务到工具侧
- 本系统无需额外控制任务队列

---

## 9. 数据模型

### 9.1 扫描配置表（auto_scan_config）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| scan_type | varchar | 扫描类型：baseline/weak_pwd/sys_vuln/ext_vuln |
| is_enabled | tinyint | 是否开启：0-关闭，1-开启 |
| scan_day | int | 每月开始扫描日期 |
| start_time | time | 开始时间（扫描日期当天的开始时间，默认00:00） |
| max_asset_per_task | int | 单个任务最大资产数 |
| timeout_hours | int | 任务超时等待时间（小时） |
| create_user_id | bigint | 自动任务创建用户ID |
| asset_scope | varchar | 资产范围：all/reported/unreported |
| tool_id | bigint | 扫描工具ID |
| template_id | bigint | 模板ID |
| save_raw_result | tinyint | 是否保存原始结果 |
| blind_time_interval | int | 距盲时间隔（小时） |
| last_exec_time | datetime | 上次执行时间 |
| create_time | datetime | 创建时间 |
| update_time | datetime | 更新时间 |

**说明**：下次执行时间通过查询 `auto_scan_round` 表中 pending 状态的记录获取，不在配置表冗余存储。

**索引建议**：
- `idx_scan_type` (scan_type) - 按扫描类型查询配置

### 9.2 扫描配置-业务系统关联表（auto_scan_config_system）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| config_id | bigint | 扫描配置ID |
| system_id | bigint | 业务系统ID |
| sort_order | int | 执行顺序（从资产组显示顺序获取） |

**索引建议**：
- `idx_config_id` (config_id) - 按配置ID查询关联的业务系统

### 9.3 盲时配置表（auto_scan_blind_time）

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| config_id | bigint | 扫描配置ID |
| blind_type | varchar | 盲时类型：month/date/time_range |
| blind_value | varchar | 盲时值：月份(11)/日期(10-01)/时间段(06:00-18:00) |

**索引建议**：
- `idx_config_id` (config_id) - 按配置ID查询盲时规则

### 9.4 扫描轮次表（auto_scan_round）

记录每一轮调度的整体情况。

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| config_id | bigint | 扫描配置ID |
| task_version | varchar | 任务版本/月份（如：202601） |
| round_no | int | 本月轮次序号（1=本月第一轮，2=本月第二轮...），skipped/cancelled 状态也正常递增，展示时补零为两位（01, 02...） |
| round_tag | varchar | 轮次唯一标识，格式：{月份}_{触发类型}_{轮次序号(补零)}，如：202501_自动_01、202501_手动_02。用于AMR任务名称，便于搜索查询同一批任务 |
| trigger_type | varchar | 触发类型：auto/manual |
| status | varchar | 状态：pending/waiting/running/success/failed/partial_failed/skipped/cancelled |
| skip_reason | varchar | 跳过原因（status=skipped时记录，如"上轮任务未完成且已超时"） |
| cancel_reason | varchar | 取消原因（status=cancelled时记录，如"被新的立即执行取代"） |
| fail_reason | varchar | 失败原因（status=failed/partial_failed时记录，如"服务重启导致任务创建中断"、"无符合条件的资产"、"AMR接口调用失败"等） |
| target_system_ids | varchar | 目标业务系统ID列表（逗号分隔），在 pending 创建时根据当前配置填充，配置变更时同步更新，执行时直接使用此字段作为目标业务系统 |
| target_system_count | int | 目标业务系统数量，在 pending 创建时根据当前配置填充，配置变更时同步更新，用于列表展示"共X个业务系统" |
| manual_asset_scope | varchar | 手动触发时的资产范围选择：all/failed/unscanned/failed_and_unscanned，自动触发时为null |
| total_task_count | int | 本轮任务总数（业务系统数量），pending/skipped/cancelled时为0 |
| success_task_count | int | 成功任务数，pending/skipped/cancelled时为0 |
| failed_task_count | int | 失败任务数，pending/skipped/cancelled时为0 |
| plan_start_time | datetime | 计划开始时间（pending状态时展示此时间） |
| actual_start_time | datetime | 实际开始时间 |
| end_time | datetime | 结束时间 |
| create_time | datetime | 创建时间 |
| update_time | datetime | 更新时间 |

**状态说明**：
- pending：已创建调度记录，等待到达执行时间
- waiting：到达执行时间，正在等待上轮任务完成
- running：调度执行中（正在创建任务）
- success：所有任务创建成功
- failed：所有任务创建失败
- partial_failed：部分任务创建成功，部分创建失败
- skipped：已跳过（等待超时，上轮仍未完成）
- cancelled：已取消（手动调度被新的立即执行取代，不在列表展示）

**说明**：轮次状态反映的是"任务创建结果"，而非"任务执行结果"。任务创建后的实际执行状态通过 AMR 接口实时查询。

**manual_asset_scope 字段值说明**：
- all：全部资产
- failed：上次扫描失败资产
- unscanned：本轮未扫描到的资产
- failed_and_unscanned：上次扫描失败资产 + 本轮未扫描到的资产（并集）
- null：自动触发时为空

**说明**：
- pending/skipped/cancelled 状态的轮次，任务明细表（auto_scan_round_task）无对应数据
- cancelled 状态的轮次不在"自动扫描情况跟踪"列表中展示

**索引建议**：
- `idx_config_status` (config_id, status) - 查询指定配置下特定状态的轮次（如查询 pending/waiting/running）
- `idx_config_task_version` (config_id, task_version) - 按月份筛选轮次
- `idx_status` (status) - 服务重启时查询各状态的轮次

### 9.5 扫描轮次任务明细表（auto_scan_round_task）

记录每轮调度中每个任务的基本信息。

**注意**：
- pending/skipped/cancelled 状态的轮次无任务明细数据
- 不存储任务状态和时间，避免与AMR同步维护问题，状态通过AMR接口实时查询

| 字段 | 类型 | 说明 |
|------|------|------|
| id | bigint | 主键 |
| round_id | bigint | 轮次ID（关联auto_scan_round） |
| system_id | bigint | 业务系统ID |
| system_name | varchar | 业务系统名称（冗余，便于展示） |
| exec_order | int | 执行顺序 |
| asset_count | int | 本任务资产数 |
| amr_task_id | bigint | AMR任务ID（调用AMR接口后返回） |
| amr_task_name | varchar | AMR任务名称 |
| create_time | datetime | 创建时间 |
| update_time | datetime | 更新时间 |

**索引建议**：
- `idx_round_id` (round_id) - 查询轮次下的所有任务明细
- `idx_amr_task_id` (amr_task_id) - 通过AMR任务ID反查

### 9.6 表关系说明

```
auto_scan_config (配置表)
    │
    ├── auto_scan_config_system (配置-业务系统关联)
    │
    ├── auto_scan_blind_time (盲时配置)
    │
    └── auto_scan_round (轮次表)
            │
            └── auto_scan_round_task (轮次任务明细)
```

### 9.7 关键查询场景

| 场景 | 查询方式 | 使用索引 |
|------|----------|----------|
| 判断最近一轮是否有未完成任务 | 查询 auto_scan_round 最新一条状态为 running/success/failed/partial_failed 的记录，通过 auto_scan_round_task 的 amr_task_id 调用AMR接口查询任务状态 | idx_config_status |
| 判断是否存在执行中的调度 | 查询 auto_scan_round 是否存在 status in ('waiting', 'running') 的记录 | idx_config_status |
| 判断是否存在待执行的手动调度 | 查询 auto_scan_round 是否存在 status='pending' and trigger_type='manual' 的记录 | idx_config_status |
| 判断是否存在待执行的自动调度 | 查询 auto_scan_round 是否存在 status='pending' and trigger_type='auto' 的记录 | idx_config_status |
| 获取上次扫描失败的资产 | 查询最近一次完成的轮次（状态为 success/failed/partial_failed）的 auto_scan_round_task，通过 amr_task_id 调用AMR接口查询失败的资产 | idx_config_status, idx_round_id |
| 获取本轮未扫描到的资产 | 当前配置的资产 - 最近一次完成的轮次的 auto_scan_round_task 中已包含的资产 | idx_round_id |
| 查询已跳过的轮次 | 查询 auto_scan_round 中 status='skipped' 的记录 | idx_status |
| 按月份筛选轮次列表 | 查询 auto_scan_round 按 task_version 筛选 | idx_config_task_version |
| 服务重启恢复 | 查询各状态的轮次进行恢复处理 | idx_status |

---

## 10. 边界场景处理

### 10.1 配置变更时的边界处理

| 场景 | 处理方式 |
|------|----------|
| 存在 pending 的手动调度 | 只保存配置，不影响已有的手动 pending。若不存在自动 pending 且修改了时间相关配置，则创建新的自动 pending |
| 存在 pending 的自动调度 | 仅当修改了时间相关配置时，重新计算执行时间并更新该 pending 记录 |
| 手动和自动 pending 同时存在 | 各自独立，按时间先后触发执行 |
| 有正在执行的轮次时修改配置 | 正在执行的轮次不受影响，新配置从下一轮次生效 |
| 修改业务系统范围 | 当前轮次按原配置执行，下一轮次使用新配置 |
| 修改资产范围 | 当前轮次按原配置执行，下一轮次使用新配置 |

### 10.2 手动触发的边界处理

| 场景 | 处理方式 |
|------|----------|
| 选择"上次扫描失败资产"但无失败资产 | 实际执行时检查，若无资产则轮次标记为 failed，记录原因"无符合条件的资产" |
| 选择"本轮未扫描到的资产"但资产已全部扫描 | 实际执行时检查，若无资产则轮次标记为 failed，记录原因"无符合条件的资产" |
| 同时勾选两项但并集结果为空 | 实际执行时检查，若无资产则轮次标记为 failed，记录原因"无符合条件的资产" |
| 存在 pending 的手动调度，再次选择时间触发 | 更新现有 pending 记录的计划执行时间 |
| 存在 pending 的手动调度，选择立即执行 | 将现有 pending 记录状态改为 cancelled，创建新记录立即执行 |

### 10.3 业务系统/资产变更的边界处理

| 场景 | 处理方式 |
|------|----------|
| 配置中的业务系统被删除 | 调度时跳过已删除的业务系统，记录日志 |
| 业务系统下的资产全部被删除 | 调度时跳过该业务系统（无资产可扫描），记录日志 |
| 外部漏洞扫描时业务系统下无"应用"类型资产 | 跳过该业务系统，不创建任务 |
| 所有配置的业务系统都无有效资产 | 本轮标记为 failed，记录失败原因"无有效业务系统或资产" |

### 10.4 并发控制

| 场景 | 处理方式 |
|------|----------|
| 同一扫描类型，自动调度和手动触发同时发生 | 加锁控制，同一时刻只能有一个创建任务的操作 |
| 多实例部署时的并发 | 使用分布式锁（Redis或数据库锁），避免重复触发 |

### 10.5 月份边界处理

| 场景 | 处理方式 |
|------|----------|
| 配置扫描日期为31号，当月不足31天 | 取当月最后一天（如2月取28/29号，4月取30号） |
| 下次执行时间计算 | 每次都按配置的日期计算，31号配置在2月是28/29号，在3月是31号 |

**示例**：
- 配置扫描日期：31号
- 2月28日触发调度 → 下次执行时间：3月31日
- 3月31日触发调度 → 下次执行时间：4月30日

### 10.6 跨年边界处理

| 场景 | 处理方式 |
|------|----------|
| 12月调度计算下次执行时间 | 正确计算到次年1月 |
| task_version 字段格式 | YYYYMM 格式，跨年时正确递增（202612 → 202701） |
| round_no 轮次序号 | 每月重新从1开始计数，跨年不影响 |

### 10.7 AMR接口异常处理

| 场景 | 处理方式 |
|------|----------|
| 调用AMR创建任务接口失败（网络异常、超时等） | 本轮标记为 failed，记录失败原因 |
| 部分任务创建成功、部分创建失败 | 已创建的任务正常执行，本轮最终状态为 partial_failed |
| AMR接口返回错误 | 记录错误信息到轮次记录 |

**说明**：AMR接口调用失败时不进行自动重试，需人工排查问题后通过手动触发补充。

### 10.8 轮次号规则

| 规则 | 说明 |
|------|------|
| round_no 计数范围 | 每月独立计数，从1开始 |
| 跨月重置 | 新月份第一轮 round_no = 1 |
| 同月多轮 | 递增（1, 2, 3...） |
| skipped/cancelled 状态 | 也正常递增 round_no |
| 展示格式 | 序号补零为两位（01, 02, 03...） |
| 跨月定时任务 | `task_version` 和 `round_no` 按**计划执行时间所在月份**计算，而非创建时间 |

**示例**：
- 2026年1月第1轮：task_version=202601, round_no=1, round_tag=202601_自动_01
- 2026年1月第2轮（手动触发）：task_version=202601, round_no=2, round_tag=202601_手动_02
- 2026年1月第3轮（被取消）：task_version=202601, round_no=3, round_tag=202601_手动_03, status=cancelled
- 2026年2月第1轮：task_version=202602, round_no=1, round_tag=202602_自动_01

**跨月定时任务示例**：
- 1月25日创建手动定时任务，选择2月5日 10:00 执行
- task_version=202602（按计划执行月份）
- round_no=1（2月的第1轮，假设2月之前没有其他轮次）
- round_tag=202602_手动_01

---

## 11. 接口设计

### 11.1 配置管理接口

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/auto-scan/config/{scanType} | GET | 获取指定扫描类型的配置 |
| /api/auto-scan/config/{scanType} | POST/PUT | 保存/更新配置 |
| /api/auto-scan/config/{scanType}/enable | PUT | 开启/关闭自动下发 |

### 11.2 数据查询接口

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/auto-scan/users | GET | 获取系统用户列表 |
| /api/auto-scan/systems | GET | 获取业务系统树形列表 |
| /api/auto-scan/tools/{scanType} | GET | 获取指定扫描类型的可用工具列表 |
| /api/auto-scan/templates | GET | 获取模板列表（根据工具ID筛选） |

### 11.3 轮次管理接口

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/auto-scan/rounds | GET | 获取轮次列表（支持分页、筛选） |
| /api/auto-scan/rounds/{roundId}/tasks | GET | 获取轮次任务明细 |
| /api/auto-scan/rounds/manual | POST | 手动触发新一轮次 |

### 11.4 校验接口

| 接口 | 方法 | 说明 |
|------|------|------|
| /api/auto-scan/validate/blind-time | POST | 校验盲时配置是否有效 |
| /api/auto-scan/validate/schedule-time | POST | 校验定时时间是否在盲时内 |
| /api/auto-scan/validate/can-execute | GET | 校验当前是否可以立即执行 |

---

## 12. 非功能需求

### 12.1 性能要求
- 下次执行时间计算：< 100ms
- 任务创建响应时间：< 3秒
- 支持单次创建100+任务
- 调度采用动态触发，无固定频率轮询开销

### 12.2 可靠性要求
- 服务重启后自动恢复调度任务
- 调度任务异常时记录日志并延迟重试
- 记录详细的执行日志便于排查

### 12.3 兼容性
- 与现有AMR任务管理平台接口兼容
- 与工具管理平台负载控制机制协同工作

### 12.4 部署要求
- 单机部署：无特殊要求
- 集群部署：需增加分布式锁（Redis或数据库锁），避免多实例重复触发

---

## 13. 附录

### 13.1 术语说明

| 术语 | 说明 |
|------|------|
| AMR | 任务管理平台，负责任务的创建、调度、状态管理 |
| 盲时 | 不允许下发扫描任务的时间段 |
| 轮次 | 一次完整的调度执行周期 |
| 工具管理 | 扫描工具管理平台，负责实际执行扫描任务 |
| 负载 | 工具管理平台同时处理的资产数量限制 |
| pending | 调度记录已创建，等待到达执行时间 |
| cancelled | 手动调度被新的立即执行取代 |

### 13.2 参考文档
- AMR任务管理平台接口文档
- 资产组管理功能说明
- 工具管理平台负载配置说明

### 13.3 版本历史

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| V1.0 | 2026-01-28 | 初稿 |
| V1.1 | 2026-01-29 | 补充调度机制、盲时规避等细节 |
| V1.2 | 2026-01-29 | 新增轮次状态（pending/running/cancelled），完善手动触发逻辑，明确配置变更处理规则 |
| V1.3 | 2026-01-29 | 移除skip_count字段；增加盲时配置保存校验；明确资产范围实时计算时机；增加服务重启对cancelled状态的恢复处理；补充业务系统无资产时跳过逻辑；增加数据库索引建议 |
